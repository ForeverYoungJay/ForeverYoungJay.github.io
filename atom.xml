<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YANG JIYI</title>
  
  
  <link href="https://foreveryoungjay.github.io/atom.xml" rel="self"/>
  
  <link href="https://foreveryoungjay.github.io/"/>
  <updated>2021-10-28T06:05:26.073Z</updated>
  <id>https://foreveryoungjay.github.io/</id>
  
  <author>
    <name>YANG JIYI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://foreveryoungjay.github.io/2021/10/28/test/"/>
    <id>https://foreveryoungjay.github.io/2021/10/28/test/</id>
    <published>2021-10-28T06:05:26.000Z</published>
    <updated>2021-10-28T06:05:26.073Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>active learning</title>
    <link href="https://foreveryoungjay.github.io/2021/09/19/active-learning/"/>
    <id>https://foreveryoungjay.github.io/2021/09/19/active-learning/</id>
    <published>2021-09-19T14:13:35.000Z</published>
    <updated>2021-09-19T14:29:00.851Z</updated>
    
    <content type="html"><![CDATA[<p>主动学习（Active Learning）的大致思路就是：通过机器学习的方法获取到那些比较<strong>“难”</strong>分类的样本数据，让人工再次确认和审核，然后将人工标注得到的数据再次使用有监督学习模型或者半监督学习模型进行训练，逐步提升模型的效果，将人工经验融入机器学习的模型中。</p><p>那么主动学习（Active Learning）的整体思路究竟是怎样的呢？在机器学习的建模过程中，通常包括样本选择，模型训练，模型预测，模型更新这几个步骤。在主动学习这个领域则需要把标注候选集提取和人工标注这两个步骤加入整体流程，也就是：</p><ol><li>机器学习模型：包括机器学习模型的训练和预测两部分；</li><li>待标注的数据候选集提取：依赖主动学习中的查询函数（Query Function）；</li><li>人工标注：专家经验或者业务经验的提炼；</li><li>获得候选集的标注数据：获得更有价值的样本数据；</li><li>机器学习模型的更新：通过增量学习或者重新学习的方式更新模型，从而将人工标注的数据融入机器学习模型中，提升模型效果</li></ol><p><img src="https://img2018.cnblogs.com/blog/532548/201905/532548-20190527214307519-1416709660.png" alt="img"></p><p>其中 L 是用于训练已标注的样本；</p><p>C 为一组或者一个算法模型，用户接收上一轮的标记样本集，通过负反馈调整模型参数，并输出对应的预测结果向量集；</p><p>Q 是查询函数，用于从当前剩余的未标注样本池（未标记样本会逐渐减少）U 中查询信息量最大（最不确定）的top样本；</p><p>S是督导者，可以为 U 中样本标注正确的标签；</p><p>active learning模型**通过少量初始标记样本 L 开始学习，通过一定的<font color='red'>查询函数 Q 选择出一个或一批最有用的样本</font>**，并向督导者询问标签，然后利用获得的新知识来训练分类器和进行下一轮查询。主动学习是一个循环的过程，直至达到某一停止准则为止。</p><p>需要注意的是，active learning是一个算法框架，上图中的单个模块具备可替换性（alternative）</p><p><a href="https://zhuanlan.zhihu.com/p/239756522">https://zhuanlan.zhihu.com/p/239756522</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主动学习（Active Learning）的大致思路就是：通过机器学习的方法获取到那些比较&lt;strong&gt;“难”&lt;/strong&gt;分类的样本数据，让人工再次确认和审核，然后将人工标注得到的数据再次使用有监督学习模型或者半监督学习模型进行训练，逐步提升模型的效果，将人工经验融</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图像校正(Image Rectification)</title>
    <link href="https://foreveryoungjay.github.io/2021/05/19/%E5%9B%BE%E5%83%8F%E6%A0%A1%E6%AD%A3-Image-Rectification/"/>
    <id>https://foreveryoungjay.github.io/2021/05/19/%E5%9B%BE%E5%83%8F%E6%A0%A1%E6%AD%A3-Image-Rectification/</id>
    <published>2021-05-19T07:13:19.000Z</published>
    <updated>2021-05-19T07:14:20.786Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/LoseInVain/article/details/102775734">https://blog.csdn.net/LoseInVain/article/details/102775734</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/LoseInVain/article/details/102775734&quot;&gt;https://blog.csdn.net/LoseInVain/article/details/102775734&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="CV" scheme="https://foreveryoungjay.github.io/categories/CV/"/>
    
    
  </entry>
  
  <entry>
    <title>随机抽样一致算法（RANdom SAmple Consensus,RANSAC）</title>
    <link href="https://foreveryoungjay.github.io/2021/05/19/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4%E7%AE%97%E6%B3%95%EF%BC%88RANdom-SAmple-Consensus-RANSAC%EF%BC%89/"/>
    <id>https://foreveryoungjay.github.io/2021/05/19/%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4%E7%AE%97%E6%B3%95%EF%BC%88RANdom-SAmple-Consensus-RANSAC%EF%BC%89/</id>
    <published>2021-05-19T02:34:16.000Z</published>
    <updated>2021-05-19T07:09:02.605Z</updated>
    
    <content type="html"><![CDATA[<p>一、RANSAC介绍<br>   随机抽样一致算法（RANdom SAmple Consensus,RANSAC）,采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法假设数据中包含正确数据和异常数据（或称为噪声）。正确数据记为内点（inliers），异常数据记为外点（outliers）。同时RANSAC也假设，给定一组正确的数据，存在可以计算出符合这些数据的模型参数的方法。该算法核心思想就是随机性和假设性，随机性是根据正确数据出现概率去随机选取抽样数据，根据大数定律，随机性模拟可以近似得到正确结果。假设性是假设选取出的抽样数据都是正确数据，然后用这些正确数据通过问题满足的模型，去计算其他点，然后对这次结果进行一个评分。<br>二、算法基本思想<br>（1）要得到一个直线模型，需要两个点唯一确定一个直线方程。所以第一步随机选择两个点。<br>（2）通过这两个点，可以计算出这两个点所表示的模型方程y=ax+b。<br>（3）将所有的数据点套到这个模型中计算误差。<br>（4）找到所有满足误差阈值的点。<br>（5）然后我们再重复（1）~（4）这个过程，<strong>直到达到一定迭代次数后，选出那个被支持的最多的模型，作为问题的解</strong>。如下图所示</p><p><img src="https://img-blog.csdn.net/20161201151915050" alt="img"></p><p>可以发现，虽然这个数据集中外点和内点的比例几乎相等，但是RANSAC算法还是能找到最合适的解。这个问题如果使用最小二乘法进行优化，由于噪声数据的干扰，我们得到的结果肯定是一个错误的结果，如下图所示。<strong>这是由于最小二乘法是一个将外点参与讨论的代价优化问题，而RANSAC是一个使用内点进行优化的问题。</strong>经实验验证，对于包含80%误差的数据集，RANSAC的效果远优于直接的最小二乘法。</p><p><img src="https://img-blog.csdn.net/20161201151925746" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、RANSAC介绍&lt;br&gt;   随机抽样一致算法（RANdom SAmple Consensus,RANSAC）,采用迭代的方式从一组包含离群的被观测数据中估算出数学模型的参数。RANSAC算法假设数据中包含正确数据和异常数据（或称为噪声）。正确数据记为内点（inlier</summary>
      
    
    
    
    <category term="CV" scheme="https://foreveryoungjay.github.io/categories/CV/"/>
    
    
  </entry>
  
  <entry>
    <title>对极几何</title>
    <link href="https://foreveryoungjay.github.io/2021/05/17/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/"/>
    <id>https://foreveryoungjay.github.io/2021/05/17/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/</id>
    <published>2021-05-17T14:30:54.000Z</published>
    <updated>2021-05-17T14:32:14.969Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/clarenceliang/p/6704970.html">https://www.cnblogs.com/clarenceliang/p/6704970.html</a></p><p><a href="https://blog.csdn.net/tina_ttl/article/details/52749542">https://blog.csdn.net/tina_ttl/article/details/52749542</a></p><p><a href="http://www.360doc.com/content/14/0205/14/10724725_349963695.shtml">http://www.360doc.com/content/14/0205/14/10724725_349963695.shtml</a></p><p><a href="https://zhuanlan.zhihu.com/p/79845576">https://zhuanlan.zhihu.com/p/79845576</a></p><p><a href="https://blog.csdn.net/ssw_1990/article/details/53355572">https://blog.csdn.net/ssw_1990/article/details/53355572</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/clarenceliang/p/6704970.html&quot;&gt;https://www.cnblogs.com/clarenceliang/p/6704970.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    <category term="CV" scheme="https://foreveryoungjay.github.io/categories/CV/"/>
    
    
  </entry>
  
  <entry>
    <title>Gaussian Filter &amp; Gaussian Pyramid</title>
    <link href="https://foreveryoungjay.github.io/2021/05/17/Gaussian-Filter-Gaussian-Pyramid/"/>
    <id>https://foreveryoungjay.github.io/2021/05/17/Gaussian-Filter-Gaussian-Pyramid/</id>
    <published>2021-05-17T14:08:08.000Z</published>
    <updated>2021-05-17T14:08:27.045Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_38131594/article/details/80758734">https://blog.csdn.net/qq_38131594/article/details/80758734</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_38131594/article/details/80758734&quot;&gt;https://blog.csdn.net/qq_38131594/article/details/80758734&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="CV" scheme="https://foreveryoungjay.github.io/categories/CV/"/>
    
    
  </entry>
  
  <entry>
    <title>Lucas-Kanade 追踪算法</title>
    <link href="https://foreveryoungjay.github.io/2021/05/17/Lucas-Kanade-%E8%BF%BD%E8%B8%AA%E7%AE%97%E6%B3%95/"/>
    <id>https://foreveryoungjay.github.io/2021/05/17/Lucas-Kanade-%E8%BF%BD%E8%B8%AA%E7%AE%97%E6%B3%95/</id>
    <published>2021-05-17T13:03:05.000Z</published>
    <updated>2021-05-17T13:27:55.082Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u012554092/article/details/78128795">https://blog.csdn.net/u012554092/article/details/78128795</a></p><p><a href="https://blog.csdn.net/u014568921/article/details/46638557">https://blog.csdn.net/u014568921/article/details/46638557</a></p><p>算法实现：</p><p><a href="https://blog.csdn.net/zhzhji440/article/details/43866695">https://blog.csdn.net/zhzhji440/article/details/43866695</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012554092/article/details/78128795&quot;&gt;https://blog.csdn.net/u012554092/article/details/78128795&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="CV" scheme="https://foreveryoungjay.github.io/categories/CV/"/>
    
    
  </entry>
  
  <entry>
    <title>Fourier transform and Gabor transform</title>
    <link href="https://foreveryoungjay.github.io/2021/04/23/Fourier-transform-and-Gabor-transform/"/>
    <id>https://foreveryoungjay.github.io/2021/04/23/Fourier-transform-and-Gabor-transform/</id>
    <published>2021-04-23T13:13:52.000Z</published>
    <updated>2021-04-23T13:15:07.615Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/emouse/p/3611256.html">https://www.cnblogs.com/emouse/p/3611256.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/emouse/p/3611256.html&quot;&gt;https://www.cnblogs.com/emouse/p/3611256.html&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="CV" scheme="https://foreveryoungjay.github.io/categories/CV/"/>
    
    
  </entry>
  
  <entry>
    <title>Laplacian滤波器并用于图像锐化</title>
    <link href="https://foreveryoungjay.github.io/2021/04/23/Laplacian%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%B9%B6%E7%94%A8%E4%BA%8E%E5%9B%BE%E5%83%8F%E9%94%90%E5%8C%96/"/>
    <id>https://foreveryoungjay.github.io/2021/04/23/Laplacian%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%B9%B6%E7%94%A8%E4%BA%8E%E5%9B%BE%E5%83%8F%E9%94%90%E5%8C%96/</id>
    <published>2021-04-23T12:59:44.000Z</published>
    <updated>2021-04-23T13:03:56.552Z</updated>
    
    <content type="html"><![CDATA[<p>拉普拉斯算子在平面内的数值近似<img src="https://upload-images.jianshu.io/upload_images/17221499-3e786a6fb102af0e.png" alt="img"></p><p>拉普拉斯滤波器卷积核表示</p><p><img src="https://upload-images.jianshu.io/upload_images/17221499-e20d129fc03194b2.png" alt="img"></p><p><strong>利用Laplacian滤波器实现图像的锐化</strong></p><p>​    <em><strong>由于拉普拉斯是一种微分算子，它的应用可增强图像中灰度突变的区域，减弱灰度的缓慢变化区域。</strong></em></p><p>​    因此，锐化处理可选择拉普拉斯算子对原图像进行处理，产生描述灰度突变的图像，再将拉普拉斯图像与原始图像叠加而产生锐化图像：</p><p><img src="https://upload-images.jianshu.io/upload_images/17221499-4d9aa12dca91d82e.png" alt="img"></p><p>使用拉普拉斯滤波器实现的图像锐化算法 ↑</p><p>​    其中，f(x,y)为原始图像，g(x,y)为锐化后图像，c为-1（卷积核中间为负数时，若卷积核中间为正数，则c为1）</p><p><img src="https://upload-images.jianshu.io/upload_images/17221499-d07f876233acc8f8.jpg" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/17221499-d637f9f3eed4ac8f.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;拉普拉斯算子在平面内的数值近似&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17221499-3e786a6fb102af0e.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;拉普拉斯滤波器卷积核表示&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MVC模式</title>
    <link href="https://foreveryoungjay.github.io/2021/04/23/MVC%E6%A8%A1%E5%BC%8F/"/>
    <id>https://foreveryoungjay.github.io/2021/04/23/MVC%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-04-23T06:10:00.000Z</published>
    <updated>2021-04-23T06:25:28.237Z</updated>
    
    <content type="html"><![CDATA[<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p><ul><li><p><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。模型表示企业数据和业务规则。在MVC的三个部件中，模型拥有最多的处理任务。例如它可能用像<a href="https://baike.baidu.com/item/EJB">EJB</a>s和ColdFusion Components这样的构件对象来处理数据库，被模型返回的数据是中立的，就是说模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。</p></li><li><p><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。</p><p>视图是用户看到并与之交互的界面。对老式的Web应用程序来说，视图就是由<a href="https://baike.baidu.com/item/HTML">HTML</a>元素组成的界面，在新式的Web应用程序中，<a href="https://baike.baidu.com/item/HTML">HTML</a>依旧在视图中扮演着重要的角色，但一些新的技术已层出不穷，它们包括[Adobe Flash](<a href="https://baike.baidu.com/item/Adobe">https://baike.baidu.com/item/Adobe</a> Flash)和像<a href="https://baike.baidu.com/item/XHTML">XHTML</a>，<a href="https://baike.baidu.com/item/XML">XML</a>/<a href="https://baike.baidu.com/item/XSL">XSL</a>,<a href="https://baike.baidu.com/item/WML">WML</a>等一些标识语言和[Web services](<a href="https://baike.baidu.com/item/Web">https://baike.baidu.com/item/Web</a> services).</p><p>MVC好处是它能为应用程序处理很多不同的<a href="https://baike.baidu.com/item/%E8%A7%86%E5%9B%BE">视图</a>。在视图中其实没有真正的处理发生，不管这些数据是联机存储的还是一个雇员列表，作为视图来讲，它只是作为一种输出数据并允许用户操纵的方式。</p></li><li><p><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。控制器接受用户的输入并调用模型和视图去完成用户的需求，所以当单击Web页面中的超链接和发送<a href="https://baike.baidu.com/item/HTML%E8%A1%A8%E5%8D%95">HTML表单</a>时，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。</p></li></ul><p><img src="https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150024694-1439613206.jpg" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150019101-1710764799.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Model（模型）&lt;/strong&gt; - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带</summary>
      
    
    
    
    <category term="Java" scheme="https://foreveryoungjay.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java没有main方法如何运行</title>
    <link href="https://foreveryoungjay.github.io/2021/04/22/Java%E6%B2%A1%E6%9C%89main%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/"/>
    <id>https://foreveryoungjay.github.io/2021/04/22/Java%E6%B2%A1%E6%9C%89main%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C/</id>
    <published>2021-04-22T14:39:02.000Z</published>
    <updated>2021-04-22T14:39:39.185Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在该方法中构造main函数</strong></p><p>Sources 一般用于标注类似 src 这种可编译目录。有时候我们不单单项目的 src 目录要可编译，还有其他一些特别的目录也许我们也要作为可编译的目录，就需要对该目录进行此标注。只有 Sources 这种可编译目录才可以新建 Java 类和包，这一点需要牢记。<br>Tests 一般用于标注可编译的单元测试目录。在规范的 maven 项目结构中，顶级目录是 src，maven 的 src 我们是不会设置为 Sources 的，而是在其子目录 main 目录下的 java 目录，我们会设置为 Sources。而单元测试的目录是 src - test - java，这里的 java 目录我们就会设置为 Tests，表示该目录是作为可编译的单元测试目录。一般这个和后面几个我们都是在 maven 项目下进行配置的，但是我这里还是会先说说。从这一点我们也可以看出 IntelliJ IDEA 对 maven 项目的支持是比彻底的。<br>Resources 一般用于标注资源文件目录。在 maven 项目下，资源目录是单独划分出来的，其目录为：src - main -resources，这里的 resources 目录我们就会设置为 Resources，表示该目录是作为资源目录。资源目录下的文件是会被编译到输出目录下的。<br>Test Resources 一般用于标注单元测试的资源文件目录。在 maven 项目下，单元测试的资源目录是单独划分出来的，其目录为：src - test -resources，这里的 resources 目录我们就会设置为 Test Resources，表示该目录是作为单元测试的资源目录。资源目录下的文件是会被编译到输出目录下的。<br>Excluded 一般用于标注排除目录。被排除的目录不会被 IntelliJ IDEA 创建索引，相当于被 IntelliJ IDEA 废弃，该目录下的代码文件是不具备代码检查和智能提示等常规代码功能。<br>通过上面的介绍，我们知道对于非 maven 项目我们只要会设置 src 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;在该方法中构造main函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Sources 一般用于标注类似 src 这种可编译目录。有时候我们不单单项目的 src 目录要可编译，还有其他一些特别的目录也许我们也要作为可编译的目录，就需要对该目录进行此标注。只有 Sourc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>快速补全代码</title>
    <link href="https://foreveryoungjay.github.io/2021/04/22/%E5%BF%AB%E9%80%9F%E8%A1%A5%E5%85%A8%E4%BB%A3%E7%A0%81/"/>
    <id>https://foreveryoungjay.github.io/2021/04/22/%E5%BF%AB%E9%80%9F%E8%A1%A5%E5%85%A8%E4%BB%A3%E7%A0%81/</id>
    <published>2021-04-22T14:36:59.000Z</published>
    <updated>2021-04-22T14:37:57.383Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将鼠标放在接口的名称处按 Alt+Enter 键</strong></p><p>实现接口：<strong>鼠标左键单击：Implement interface ，进入创建实现类的名字以及指明其所在的包的界面。选择好之后，点击ok即可完成</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;将鼠标放在接口的名称处按 Alt+Enter 键&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现接口：&lt;strong&gt;鼠标左键单击：Implement interface ，进入创建实现类的名字以及指明其所在的包的界面。选择好之后，点击ok即可完成&lt;/strong&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>摄像机原理</title>
    <link href="https://foreveryoungjay.github.io/2021/04/22/%E6%91%84%E5%83%8F%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    <id>https://foreveryoungjay.github.io/2021/04/22/%E6%91%84%E5%83%8F%E6%9C%BA%E5%8E%9F%E7%90%86/</id>
    <published>2021-04-22T13:37:23.000Z</published>
    <updated>2021-04-22T13:39:49.760Z</updated>
    
    <content type="html"><![CDATA[<p>The first important content is the <strong>image forming process.</strong> The image is an array. There is only one array for black and white images, and there are three arrays for color images. Then the picture is recorded by the camera because of the black box camera and the principle of small hole forming. There is a perspective effect through the camera, and the parallel lines will converge at a vanishing point in the distance in the picture. <strong>Homogeneous coordinates</strong> represent a vector that is originally n-dimensional with an n+1-dimensional vector, which refers to a coordinate system used in projection geometry, just like <strong>Cartesian coordinates used in Euclidean geometry.</strong> 2D and 3D transformations include homogeneous coordinates and transformation.</p><p><strong>The intrinsic matrix</strong>: The focal length is from the pointer hole to the film, where the unit of focal length in pixels. <strong>The extrinsic matrix</strong> is used to describe the position of the camera in the “world coordinate system” and the direction it points to. The field of view depends on the focal length, the larger the <strong>focal length</strong>, the smaller the field of view. The smaller the focal length, the larger the field of view. The above is the position of the object in the photo, and the next is the pixel size. The biggest function of the <strong>large aperture</strong> is to highlight the subject, blur the background, and create a sense of hierarchy. The small aperture has a large clear range and is suitable for shooting themes such as scenery, travel, and documentary. The scenery is shot with a small aperture. With the pan-focus operation, the entire huge spatial scale picture can be located in a clear range. Finally, the digital camera, using imaging sensors.</p><p>The second part is <strong>image processing</strong>, Proposed the <strong>Aliasing problem</strong>, the harm caused by down-sampling danger, Characteristic errors will appear. The solution involves multiple sampling to eliminate frequencies higher than half of the new sampling, Including <strong>Gaussian filtering</strong>.</p><p><strong>Tone mapping</strong> makes the Incoming light energy and the Image intensity value not linear.</p><p><strong>Bilinear interpolation</strong> is a linear interpolation extension of an interpolation function with two variables. Its core idea is to perform a linear interpolation in two directions. </p><p><strong>Chromatic aberration:</strong> Different colors of light have different wavelengths. Therefore, the focal plane of light passing through the lens and light of different wavelengths will be slightly different. Besides, the angles of the chromatic images after passing through the lens will be slightly staggered when they reach the focal plane. That is, the seven basic colors of light reach different focal points. </p><p><strong>Histogram Equalization</strong>: It is often used to enhance the overall contrast of the picture, especially for those cases where useful data is represented by similar data. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;The first important content is the &lt;strong&gt;image forming process.&lt;/strong&gt; The image is an array. There is only one array for black and w</summary>
      
    
    
    
    <category term="CV" scheme="https://foreveryoungjay.github.io/categories/CV/"/>
    
    
  </entry>
  
  <entry>
    <title>Statement和PrepareStatement的区别详解</title>
    <link href="https://foreveryoungjay.github.io/2021/04/21/Statement%E5%92%8CPrepareStatement%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/"/>
    <id>https://foreveryoungjay.github.io/2021/04/21/Statement%E5%92%8CPrepareStatement%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-21T15:08:29.000Z</published>
    <updated>2021-04-22T06:49:59.475Z</updated>
    
    <content type="html"><![CDATA[<p>联系：<br>1.PreparedStatement继承自Statement，两者都是接口。<br>2.内部都要建立类似于Sockt连接，效率都不是特别高。</p><p>从资源利用和安全的角度区分两者的不同：</p><p>关于批处理时如何选择，以数据量大小位标准分三种情况：<br>1）量比较小，二者皆差别不大。<br>2）量比较多，在PreparedStatement预编译空间范围之内，选择PreparedStatement，因为其只预编译一次sql语句。<br>3）量特别大，使用Statement，因为PrepareStatement的预编译空间有限，当数据量特别大时，会发生异常。<br>特殊情况还有：执行不同的sql语句，批处理…等等 ，可以从消耗资源的角度再次分析。</p><p>批处理综合分析：<br>使用PreparedStatement代码演示：<br>在批处理过程中包含的sql语句的主干部分(sql语句)必须相同，改变的只是参数，因此编译一次sql语句即可，极大提高性能，但其主干必须相同则影响了灵活性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> 2         Connection conn = null;</span><br><span class="line"> 3         Statement stat = null;</span><br><span class="line"> 4         PreparedStatement ps = null;</span><br><span class="line"> 5         </span><br><span class="line"> 6         try &#123;</span><br><span class="line"> 7             Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"> 8             conn = DriverManager.getConnection(&quot;jdbc:mysql:///mydb5&quot;,&quot;root&quot;,&quot;admin&quot;);</span><br><span class="line"> 9             //开始事务</span><br><span class="line">10             conn.setAutoCommit(false);</span><br><span class="line">11             String sql = &quot;insert into tb_batch values (null,?)&quot;;</span><br><span class="line">12             ps = conn.prepareStatement(sql);</span><br><span class="line">13             for(int i=2000;i&lt;3000;i++)&#123;</span><br><span class="line">14                 ps.setString(1, &quot;tong&quot;+i);</span><br><span class="line">15                 ps.addBatch();</span><br><span class="line">16             &#125;</span><br><span class="line">17             ps.executeBatch();</span><br><span class="line">18             //提交事务</span><br><span class="line">19             conn.commit();</span><br><span class="line">22         &#125; catch (Exception e) &#123;</span><br><span class="line">23             e.printStackTrace();</span><br><span class="line">24         &#125;finally&#123;</span><br><span class="line">25             JDBCutils.closeResou(conn, ps, null);</span><br><span class="line">26         &#125;     </span><br><span class="line">29     &#125;</span><br></pre></td></tr></table></figure><p>使用Statement代码演示：<br>可以包含结构不同的sql语句，灵活性得到提高，但没有预编译机制, 效率低下；并且你会发现发送的sql语句主干部分相同，只是参数不同， 但是主干部分每次都需要重复写入，极为麻烦。.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = null;</span><br><span class="line"> 4         Statement stat = null;</span><br><span class="line"> 5         //注册驱动和连接数据库</span><br><span class="line"> 6         conn = JDBCutils.getConn();</span><br><span class="line"> 7         try &#123;</span><br><span class="line"> 8             stat = conn.createStatement();</span><br><span class="line"> 9             stat.addBatch(&quot;drop database if exists mydb5&quot;);</span><br><span class="line">10             stat.addBatch(&quot;create database mydb5&quot;);</span><br><span class="line">13             stat.addBatch(&quot;insert into tb_batch values(null,&#x27;a&#x27;)&quot;);</span><br><span class="line">14             stat.addBatch(&quot;insert into tb_batch values(null,&#x27;bbb&#x27;)&quot;);</span><br><span class="line">15             stat.addBatch(&quot;insert into tb_batch values(null,&#x27;cccccc&#x27;)&quot;);</span><br><span class="line">16             stat.executeBatch();     </span><br><span class="line">19         &#125; catch (Exception e) &#123;</span><br><span class="line">20             e.printStackTrace();</span><br><span class="line">21         &#125;finally&#123;</span><br><span class="line">22             JDBCutils.closeResou(conn, stat, null);</span><br><span class="line">23         &#125;</span><br><span class="line">24         </span><br></pre></td></tr></table></figure><p><strong>从数据库安全的角度：</strong><br>PreparedStatement可防止SQL注入。SQL注入情况如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//输入要删除的账户：&#x27;abc&#x27; or 1=1</span><br><span class="line">String username=&quot;&#x27;abc&#x27; or 1=1&quot;</span><br><span class="line"> </span><br><span class="line">//等待用户输入的SQL语句</span><br><span class="line">String sql=select * from user where username =&#x27;&quot;+username+&quot;&#x27;;</span><br></pre></td></tr></table></figure><p>可以发现输入密码时，已经属于非法输入<br>使用Statement 的话最后的sql语句则是如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name = &#x27;abc&#x27; or 1=1;</span><br></pre></td></tr></table></figure><p>数据库容易被人恶意全部删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;联系：&lt;br&gt;1.PreparedStatement继承自Statement，两者都是接口。&lt;br&gt;2.内部都要建立类似于Sockt连接，效率都不是特别高。&lt;/p&gt;
&lt;p&gt;从资源利用和安全的角度区分两者的不同：&lt;/p&gt;
&lt;p&gt;关于批处理时如何选择，以数据量大小位标准分三种情</summary>
      
    
    
    
    <category term="数据库" scheme="https://foreveryoungjay.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>What&#39;s this website</title>
    <link href="https://foreveryoungjay.github.io/2021/04/17/What-s-this-website/"/>
    <id>https://foreveryoungjay.github.io/2021/04/17/What-s-this-website/</id>
    <published>2021-04-17T14:50:03.000Z</published>
    <updated>2021-04-18T02:05:24.705Z</updated>
    
    <content type="html"><![CDATA[<p>此网站仅为学习过程中的笔记，供大家分享。</p><p><strong>一緒に頑張りましょう！</strong></p><p><strong>What I’m doing right now, I’m chasing perfection.</strong></p><p>如有疑问请发邮件到 <a href="mailto:&#49;&#51;&#48;&#49;&#x34;&#50;&#48;&#52;&#50;&#55;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#109;">&#49;&#51;&#48;&#49;&#x34;&#50;&#48;&#52;&#50;&#55;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#109;</a></p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1872327711,3275977009&fm=26&gp=0.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此网站仅为学习过程中的笔记，供大家分享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一緒に頑張りましょう！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What I’m doing right now, I’m chasing perfection.&lt;/strong&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
</feed>
